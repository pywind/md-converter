"""Data models for job management services."""

from __future__ import annotations

import json
import threading
from dataclasses import asdict, dataclass, field
from datetime import datetime
from enum import Enum
from hashlib import sha256
from pathlib import Path
from typing import Literal

from ..models import ConversionOptions


class JobStatus(str, Enum):
    """Lifecycle states for a background conversion job."""

    QUEUED = "queued"
    RUNNING = "running"
    SUCCEEDED = "succeeded"
    FAILED = "failed"
    CANCELED = "canceled"
    EXPIRED = "expired"


@dataclass(slots=True)
class JobArtifacts:
    """Artifacts generated by a completed job."""

    output_md_path: str | None = None
    assets_dir_path: str | None = None
    run_dir_path: str | None = None
    output_zip_path: str | None = None
    size_bytes_md: int = 0
    size_bytes_assets_total: int = 0


@dataclass(slots=True)
class JobOptions:
    """User-provided options influencing job execution."""

    image_policy: Literal["extract", "ignore"] = "extract"
    size_limit_mb: int | None = None
    timeout_s: int | None = None
    normalize_headings: bool = True
    output_mode: Literal["md", "zip", "both"] = "md"
    dedupe: bool = False

    def to_conversion_options(self) -> ConversionOptions:
        return ConversionOptions(
            size_limit_mb=self.size_limit_mb,
            timeout_s=self.timeout_s,
            image_policy=self.image_policy,
            normalize_headings=self.normalize_headings,
            output_mode=self.output_mode,
        )

    def as_dict(self) -> dict[str, object]:
        return {
            "image_policy": self.image_policy,
            "size_limit_mb": self.size_limit_mb,
            "timeout_s": self.timeout_s,
            "normalize_headings": self.normalize_headings,
            "output_mode": self.output_mode,
        }

    def signature(self) -> str:
        payload = json.dumps(self.as_dict(), sort_keys=True, separators=(",", ":"))
        return sha256(payload.encode("utf-8")).hexdigest()


@dataclass(slots=True)
class JobRecord:
    """Persistent representation of job status."""

    job_id: str
    status: JobStatus
    progress: float = 0.0
    submitted_at: str | None = None
    started_at: str | None = None
    finished_at: str | None = None
    warnings: list[str] = field(default_factory=list)
    error_code: str | None = None
    error_message: str | None = None
    artifacts: JobArtifacts | None = None
    options: dict[str, object] = field(default_factory=dict)
    parent_job_id: str | None = None
    reused: bool = False
    input_hash: str | None = None

    def to_payload(self) -> dict[str, object | None]:
        payload = asdict(self)
        payload["status"] = self.status.value
        if self.artifacts is not None:
            payload["artifacts"] = asdict(self.artifacts)
        return payload


@dataclass(slots=True)
class JobHandle:
    """In-memory handle for a submitted job."""

    job_id: str
    filename: str
    source_path: Path
    options: JobOptions
    parent_job_id: str | None
    cancel_event: threading.Event
    submitted_at: datetime
    input_hash: str


__all__ = [
    "JobStatus",
    "JobArtifacts",
    "JobOptions",
    "JobRecord",
    "JobHandle",
]
